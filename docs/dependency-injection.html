<h1>Dependency Injection</h1>
<p>HtmlRapier uses dependency injection when creating controllers to bring in any additional dependencies. The dependency injector works on a hierarchy based on 2 classes. The first is the <strong>ServiceCollection</strong>, which defines all the services (object constructors and lifetimes) and the other is the <strong>Scope</strong>, which holds resolved services.</p>
<p>There are two types of lifetimes currently supported, <strong>transient</strong> and <strong>shared</strong>. Transient will create a new instance each time the service is requested. Shared will create an instance the first time it is requested and then never again after that. To help manage these lifetimes you can create stacks of ServiceCollections. Using this you can add shared instances to child ServiceCollections and use different instances of the same classes with different groups of objects.</p>
<p>To demonstrate this imagine you have a page with 2 crud tables on it that you want separate, but you also have some connections to the server side you want to reuse between them. You have also created some reusable controllers that define the table itself and the rows in that table. To make the rows know about the table itself you add the table as a shared instance so you only have one and the rows as transient to make a new one each time. You also add the data services you need. However, now we run into a problem. We can create the first table, but the second one appears to be just a part of the first.</p>
<p>So instead of using the layout described above first create a controller builder to act as a root builder and add your shared data services there. Then create a child builder and setup the services for table one, the same way with a shared table controller and transient row controllers. Create another separete child builder from the root builder and add your other set of table controller services to it. Now create each controller using its unique builder. This time everything will be created correctly, but the services defined in the root builder will be shared between the two instances.</p>
<p>The shared concept for this di system is sort of a combo between the singleton and scoped instance you might see in other di systems. Those are perfectly fine, but we were unable to think of a generic time to create a new scope&nbsp;so we leave this to the client programmer. The only exception to this is when you inject a controller builder into a controller, in that case a new child builder is created upon injection.</p>
<p>There are two major ways to add services, either with the addX or tryAddX functions. The tryAdd version will not add a service again if it already exists in the current service collection level. This is a good way to provide default services by having your users call an addServices function you provide. More on this below. Also the tryAddX versions will not check parent ServiceCollecitons for the existance of a service before adding it, so you must make sure you are talking to the same SeriveCollection instance as anything else you are trying to block from being added.</p>
<h2>Reccomendations for Dependency Injection</h2>
<p>If you build a module or library that you want others to consume you should always provide a correctly setup set of default services or barring that document the additional services the user will have to inject. It is reccomended to export an addServices function that should be called by every user of your module. In that function use the tryAddSingleton or tryAddScoped&nbsp;functions to add your services. This will allow the user to override them, but makes it easy for them to get them all setup. Also, by doing things this way you can update your library to inject something new into some of your classes without having to update all the consuming client code, just update the library and go.</p>